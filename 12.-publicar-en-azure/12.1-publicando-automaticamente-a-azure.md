# 12.1 Publicando automáticamente a Azure

Podemos modificar nuestro Pipeline para que al momento de que se le da commit aparte de correr las pruebas automáticas, generé el script para actualizar la base de datos, y genere los archivos necesarios para publicar en Azure \(Artifacts\). 

En el ejemplo voy a publicar los artifacts. Solo como ejemplo para demostrar diferentes formas de publicar el mismo código a diferentes servidores, voy a publicar un Artifact para desplegar los servicios en el AppService con Linux con Azure con una base de datos MySQL y también voy a generar un Artifact para publicar en un hosting windows por FTP.

Vamos a crear en una variable de tipo Secret la cadena de conexión donde vamos a tener nuestra base de datos de MySQL puedes tener la bd de MySQL en un hosting, un servidor o en Azure. Esta cadena de conexión se va a reemplazar en el momento en que generamos el  Pipeline para poder generar el script que actualizará la base de datos.

### 12.1.1 Modificando el Pipeline para generar el Artifact para publicar a Azure.

1. Entramos a Azure Devops en la opción Pipelines. Selecciona el último Pipeline y da clic en **Edit**.

![](../.gitbook/assets/image%20%28252%29.png)

2. Damos clic en el botón **Variables** para agregar una variable de tipo secret que tendra nuestra cadena de conexión, al tenerla en variable la cadena de conexión no esta disponible en el código fuente. 

![](../.gitbook/assets/image%20%28267%29.png)

3. Da clic en el botón **+** para agregar una nueva variable. En la imagen ya tengo agregada la imagen, como es de tipo secreta solo se ve el nombre pero no el valor. 

![](../.gitbook/assets/image%20%28368%29.png)

Como ejemplo voy a agregar otra variable para la base de datos de SQL de Azure. Con el nombre AzureSQLServer y en value agrego la cadena de conexión de Azure

```text
Server=tcp:armhe.database.windows.net,1433;Initial Catalog=CaducaRest;Persist Security Info=False;User ID=AdminCaduca;Password=tuPassword;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;
```

![](../.gitbook/assets/image%20%28161%29.png)

Puedes ver que se agrega la variable. Da clic en **Save**

![](../.gitbook/assets/image%20%28231%29.png)

En la sección de variables puedes agregar las variables que deseas cambiar de tu archivo appsettings.json

{% code title="appsettings.json" %}
```javascript
{
  "ConnectionStrings": {
    "DefaultConnection": "server=localhost;port=3306;database=caduca;user=AdminCaduca;Password=StKRV6MR6A;sslMode=none",
    "SQLServerConnection": "Server=localhost;Database=caduca;User Id=AdminCaduca;Password=StKRV6MR6A;",
    "AzureSQLConnection": "Server=tcp:armhe.database.windows.net,1433;Initial Catalog=CaducaRest;Persist Security Info=False;User ID=AdminCaduca;Password=StKRV6MR6A;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
  },
  "Tokens": {
    "Key": "4eQXP7GTCTRwC6x6",
    "Issuer": "http://localhost:5000",
    "Audience": "http://localhost:5000"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Debug"
    }
  },
  "AllowedHosts": "*"
}
```
{% endcode %}

Por ejemplo para cambiar la cadena de Conexión **DefaultConnection** debemos agregar una variable con el nombre **ConnectionStrings.DefaultConnection**, para cada nivel del json se sustituye con un punto \(.\). Para utilizar las variables que definimos agregamos la variable con $ y entre paréntesis. Ejemplo **$\(Mysql\).**

```yaml
variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
  system.debug: false
  ConnectionStrings.DefaultConnection: $(Mysql)

```

Para practicar el remplazo de variables puedes agregar variables para cambiar el key, Issuer, Audience, el nivel de log, con variables secretas o directamente en el código yaml. Como el código yaml se incluye en el repositorio de Github, es mejor utilizar variables para los valores que no deseas que esten disponibles para cualquier programador.

El archivo yaml queda de la siguiente manera**:**

\*\*\*\*

