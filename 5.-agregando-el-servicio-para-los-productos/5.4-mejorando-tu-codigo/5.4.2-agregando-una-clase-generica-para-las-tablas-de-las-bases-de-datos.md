# 5.5.2 Agregando clases genéricas para las tablas

Si observamos el código de nuestras clases de acceso a las bases de datos es bastante similar, para evitar estar repitiendo el código, vamos a crear una clase genérica con los métodos comunes como son obtener todos los registros, obtener un registro por id, agregar, modificar y borrar un registro.

Como cada tabla puede tener diferentes validaciones para agregar, borrar o modificar vamos a agregar una interfaz que nos permita validar cada regla de forma individual. Por ejemplo, podemos tener una regla para validar que el nombre de la categoría no se repita. Otra regla para validar que no se repita la clave de la categoría. De esta forma podemos probar las reglas de forma individual para encontrar mas rápido algún error. Agregamos una interfaz **IRegla** en nuestra carpeta **Core**

{% code title="IRegla.cs" %}
```csharp
public interface IRegla
{   
    CustomError customError { get; set; }
    bool EsCorrecto();
}
```
{% endcode %}

Primero vamos a crear una interfaz llamada **IAccesoDAO** en nuestra carpeta **Core**, esta interfaz cual contiene los métodos comunes, el cual utiliza generics, en el cual se recibe un objeto como parámetro, este objeto sera el nombre de la clase de la base de datos, por ejemplo Categoria, Producto.

{% code title="IAccesoDao.cs" %}
```csharp
public interface IAccesoDAO<T> where T : class
{
    CustomError customError { get; set; }
    Task<List<T>> ObtenerTodoAsync();       
    Task<T> ObtenerPorIdAsync(int id);
    Task<bool> AgregarAsync(T registro, List<IRegla> reglas);
    Task<bool> ModificarAsync(T registro, List<IRegla> reglas);
    Task<bool> BorraAsync(int id, List<IRegla> reglas);
}
```
{% endcode %}

Ahora vamos a crear una clase **AccesoDAO** el cual tiene el código general para las tablas

{% code title="AccesoDAO.cs" %}
```csharp
public class AccesoDAO<TEntity> : IAccesoDAO<TEntity> where TEntity : class
{
    private readonly CaducaContext contexto;
    private readonly LocService localizacion;
    public CustomError customError { get; set; }

    public AccesoDAO(CaducaContext context, LocService locService)
    {
        this.contexto = context;
        this.localizacion = locService;
    }

    public async Task<bool> AgregarAsync(TEntity registro, 
                                         List<IRegla> reglas)
    {       
        foreach(var regla in reglas)
        {
            if (!regla.EsCorrecto())
            {
                customError = regla.customError;
                return false;
            }
        }
        contexto.Set<TEntity>().Add(registro);
        await contexto.SaveChangesAsync();

        return true;
    }

    public async Task<bool> BorraAsync(int id, List<IRegla> reglas,
                                       string nombreTabla)
    {       
         var registro = await ObtenerPorIdAsync(id);
         if (registro == null)
         {
             customError = new CustomError(404, String.Format(
               this.localizacion.GetLocalizedHtmlString("NotFound"),
                   nombreTabla), "Id");
             return false;
          }
          foreach(var regla in reglas)
          {
              if (!regla.EsCorrecto())
              {
                  customError = regla.customError;
                  return false;
              }
          }
          contexto.Set<TEntity>().Remove(registro);
          await contexto.SaveChangesAsync();
          return true;
    }

    public async Task<bool> ModificarAsync(TEntity registro, 
                                            List<IRegla> reglas)
    {           
        foreach(var regla in reglas)
        {
            if (!regla.EsCorrecto())
            {
                customError = regla.customError;
                return false;
            }
        }
        contexto.Entry(registro).State = EntityState.Modified;
        await contexto.SaveChangesAsync();
        return true;
    }
        
    public  async Task<TEntity> ObtenerPorIdAsync(int id)
    {
            return await contexto.Set<TEntity>().FindAsync(id);
    }

     public async Task<List<TEntity>> ObtenerTodoAsync()
     {
         return await contexto.Set<TEntity>().ToListAsync();
     }     
}
```
{% endcode %}

### 5.5.2.1 Agregando Reglas

Ahora cambiamos nuestra clase **CategoriaDAO** para que utilice nuestra clase **AccesoDAO** y para el método Agregar creamos 2 reglas una para validar el nombre repetido, otra para la clave.

Agregamos una carpeta llamada Rules la cual contendrá todas las reglas para todas las tablas. Agregamos una carpeta para la tabla Categoría. Creamos 2 clases una para validar que la clave no se repita y otra para validar que el nombre no se repita.

Por defecto las consultas que se hacen a las bases de datos se regresan objetos que internamente llevan un control de los campos para al momento de realizar un SaveChanges se guarden los cambios a todos los objetos que se han cambiado, para estas reglas solo necesitamos si existe un registro no deseamos llevar el control de cambios, esto se realiza agregando **AsNoTracking\(\)** en nuestras consultas, de esta manera se le indica a Entity Framework que el objeto es de solo lectura por lo cual hace el proceso mas eficiente.

{% code title="AgregarClaveRegla.cs" %}
```csharp
public class AgregarClaveRegla: IRegla
{
	private int clave;
	private readonly CaducaContext contexto;
	private readonly LocService localizacion;

	public AgregarClaveRegla(int clave, CaducaContext context,
	                          LocService locService)
	{
		this.clave = clave;
		this.contexto = context;
		this.localizacion = locService;
	}
	public CustomError customError { get; set; }
   
	public bool EsCorrecto()
	{
		var registroRepetido = contexto.Categoria.AsNoTracking()
		                    .FirstOrDefault(c => c.Clave == clave);
		if (registroRepetido != null)
		{
			customError = new CustomError(400, String.Format(
			this.localizacion.GetLocalizedHtmlString("Repeteaded"),
			 "categoría", "clave"), "Clave");
			return false;
		}
		return true;
	}
}
```
{% endcode %}

{% code title="AgregarNombreRegla.cs" %}
```csharp
public class AgregarNombreRegla: IRegla
{
	private string nombre;
	private readonly CaducaContext contexto;
	private readonly LocService localizacion;

	public AgregarNombreRegla(string nombre, CaducaContext context,
	                          LocService locService)
	{
		this.nombre = nombre;
		this.contexto = context;
		this.localizacion = locService;
	}
	public CustomError customError { get; set; }

	public bool EsCorrecto()
	{
		var registroRepetido = contexto.Categoria.AsNoTracking()
		                .FirstOrDefault(c => c.Nombre == nombre);
		if (registroRepetido != null)
		{
			customError = new CustomError(400, String.Format(
			  this.localizacion.GetLocalizedHtmlString("Repeteaded"),
			 "categoría", "nombre"), "Nombre");
			return false;
		}
		return true;
	}
}
```
{% endcode %}

Modificamos nuestra clase **CategoriaDAO** agregando nuestra clase AccesoDAO pasando como parámetro la tabla Categoria, cambiamos el método AgregarAsync para crear una regla para validar que no este repetido el nombre y otra para que no este repetido la clave. Luego pasamos el arregla de reglas a validar.

{% code title="CategoriaDAO.cs" %}
```csharp
 public class CategoriaDAO
{
    private AccesoDAO<Categoria> categoriaDAO;
    
    public async Task<List<Categoria>> ObtenerTodoAsync()
    {
        return await categoriaDAO.ObtenerTodoAsync();
    }
    
    public async Task<Categoria> ObtenerPorIdAsync(int id)
    {
         return await categoriaDAO.ObtenerPorIdAsync(id);
    }
    
    public async Task<bool> AgregarAsync(Categoria categoria)
    {
        //Reglas para validar
        AgregarNombreRegla nombreRepetido = 
                 new AgregarNombreRegla(categoria.Nombre, 
                                             contexto, localizacion);
        AgregarClaveRegla claveRepetido = 
                 new AgregarClaveRegla(categoria.Clave,
                                             contexto, localizacion);
        //Lista de reglas a validar
        List<IRegla> reglas = new List<Core.IRegla>();
        reglas.Add(nombreRepetido);
        reglas.Add(claveRepetido);

        if (await categoriaDAO.AgregarAsync(categoria, reglas))
            return true;
        else
        {
            customError = categoriaDAO.customError;
            return false;
        }
    }
    
    public async Task<bool> BorraAsync(int id)
    {
       if (await categoriaDAO.BorraAsync(id, new List<IRegla>(),
                                       "La categoría")) return true;
       else
       {
           customError = categoriaDAO.customError;
           return false;
        }
    } 
 }
```
{% endcode %}

Esta forma es una alternativa para validar reglas personalizadas a cualquier objeto independiente al entity framework, como por ejemplo validaciones que se pueden hacer a un archivo de excel antes de importarlo, puede parecer muchísimo más código pero nos permite validar de forma individual cada regla, lo cual lo hace más fácil de probar.

El entity framework de .net ofrece una forma más sencilla de realizar validaciones personalizadas, esto lo veremos en la siguiente lección

{% hint style="info" %}
Para practicar puedes cambiar el método Modificar y crear las reglas personalizadas para modificar y comparar con mi solución en github
{% endhint %}

